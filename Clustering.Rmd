```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(randomForest)
library(rio)
library(mltools)
library(data.table)
library(caret)
library(C50)
library(pROC)
library(plotly)
library(MLmetrics)
library(ROCR)
library(rpart)
library(psych)
library(plyr)
library(rattle)
library(rpart.plot)
library(NbClust)
```
```{r}
sorting <- function(file) {
   sortCounties <- file[order(file$County),]
   sortState <- sortCounties[order(sortCounties$State),]
   return(sortState)
}
access <- sorting(
  read.csv("FoodEnvAtlas/Access.csv",
           header = TRUE, sep = ",")
  )
restaurants <- sorting(
  read.csv("FoodEnvAtlas/Restaurants.csv",
           header = TRUE, sep = ",")
  )
priceTaxes <- sorting(
  read.csv("FoodEnvAtlas/PriceTaxes.csv",
           header = TRUE, sep = ",")
  )
health <- sorting(
  read.csv("FoodEnvAtlas/Health.csv",
           header = TRUE, sep = ",")
  )
socioec <- sorting(
  read.csv("FoodEnvAtlas/Socioeconomic.csv",
           header = TRUE, sep = ",")
  )
state <- access$State #State
county <- access$County #County
loaccgro <- access$PCT_LACCESS_POP15 #Population, low access to store (%), 2015
fasfoo <- restaurants$FSRPTH14 #Fast-food restaurants/1,000 pop, 2014
relprimilk <- priceTaxes$MILK_PRICE10 #Price of low-fat milk/national average, 2010**
diab <- health$PCT_DIABETES_ADULTS13 #Adult diabetes rate, 2013
obesrate <- health$PCT_OBESE_ADULTS13 #Adult obesity rate, 2013
fitplace <- health$RECFACPTH14 #Recreation & fitness facilities/1,000 pop, 2014
povrate <- socioec$POVRATE15 #Poverty rate, 2015
medinc <- socioec$MEDHHINC15 #Median household income, 2015
mergingData <- data.frame(state = state,
                        county = county,
                        loaccgro = loaccgro,
                        fasfoo = fasfoo,
                        diab = diab,
                        obesrate = obesrate,
                        fitplace = fitplace,
                        medinc = medinc)
county_data <- na.omit(mergingData)

```

```{r}
# remove state, coutny, and povrate columns and normalize the data
county_data <- county_data %>% select(-c(state, county))
normalize <- function(x){
 (x - min(x)) / (max(x) - min(x))
}

county_data[,c(1:7)] <- lapply(county_data[,c(1:6)], normalize)

# create obesrateLevel column to turn it into a classification problem
county_data <-county_data %>% mutate(obesrateLevel = ifelse(obesrate >= 0.7, "high", "low"))

# remove obesrateLevel for clustering
clust_county <- county_data %>% select(-c("obesrateLevel"))
```

```{r}
# use elbow chart to find best number of centers for kmeans
explained_variance = function(data_in, k){
  
  # Running the kmeans algorithm.
  set.seed(1)
  kmeans_obj = kmeans(data_in, centers = k, algorithm = "Lloyd", iter.max = 30)
  
  # Variance accounted for by clusters:
  # var_exp = intercluster variance / total variance
  var_exp = kmeans_obj$betweenss / kmeans_obj$totss
  var_exp  
}

explained_var_county = sapply(1:10, explained_variance, data_in = clust_county)

elbow_data_county = data.frame(k = 1:10, explained_var_county)

# Plotting data.
ggplot(elbow_data_county, 
       aes(x = k,  
           y = explained_var_county)) + 
  geom_point(size = 4) +           #<- sets the size of the data points
  geom_line(size = 1) +            #<- sets the thickness of the line
  xlab('k') + 
  ylab('Inter-cluster Variance / Total Variance') + 
  theme_light()

```

```{r}
# 4 centers was found to be the best
set.seed(1)
kmeans_obj_county = kmeans(clust_county, centers = 4, 
                        algorithm = "Lloyd")   #<- there are several ways of implementing

kmeans_obj_county

kmeans_obj_county$cluster

# create column for cluster assignment
county_cluster_data <- cbind(county_data, clusterNum = kmeans_obj_county$cluster)

# breakup the datset into their respective cluster datasets
cluster_1_data <- filter(county_cluster_data, clusterNum == 1) #Nate
cluster_2_data <- filter(county_cluster_data, clusterNum == 2) #Cesar
cluster_3_data <- filter(county_cluster_data, clusterNum == 3) #Alex
cluster_4_data <- filter(county_cluster_data, clusterNum == 4) #Liam

#write.csv(cluster_1_data,"cluster_1_data.csv", row.names = FALSE)
write.csv(cluster_2_data,"cluster_2_data.csv", row.names = FALSE)
#write.csv(cluster_3_data,"cluster_3_data.csv", row.names = FALSE)
#write.csv(cluster_4_data,"cluster_4_data.csv", row.names = FALSE)
```
